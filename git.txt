Git 과거로 돌아가는 방법 크게 2가지

Reset = 리셋은 내가 지금 최신 커밋 바로 전단계로 돌아가고 싶다면
현재 커밋을 지워버리고 바로 전 과거 커밋이 현재 커밋으로 되게끔 만듬 

Reset 하는 방법은 git reset —hard commit해시값

해시값은 git log를 통해서 확인 가능

이렇게 해서 해시값 입력 후 돌아갔을 때 돌아간 시점이 가장 최근이 되고 그렇기에 앞에 있던 더욱 최근 버전들은 사라짐


Revert = 리버트 방식은 내가 지금 바로 전 과거 단계에서 현재 단계가 될때 수정 또는 삭제 추가 한 내용들을 반대로 다시 한번 만들어서 사실상 전단계로 동일하게 커밋이 추가되는 방법

리버트 예시로 만약 1번파일 내용이 김경환이였고 여기 내용에 123을 추가하여 커밋하면 현재는 김경환123 인데 여기서 123추가한걸 반대로 제거하고 커밋을 하여 다시 김경환으로 내용을 만들고 커밋해서 결과적으로 과거 버전이였던 김경환이랑 동일한 내용을 가진 김경환이 최신 버전으로 가지게 되는 방식이다.

Revert 방법 = git revert 되돌릴 해시값

지금 위방식 실행 시 자동으로 커밋 되는데

git revert —no-commit 3e6ddae6a44a8a927c6a57936b2f1ba9010eb98e

라고 하면 add 는 되어있지만 커밋은 안됌

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


Git 특정파일 / 폴더를 배재 = .gitignore

.gitignore 파일을 만들고 그 파일안에 배제 할 파일명을 입력하면 됌

배재할 것들은 노드에서 다운받은 모듈들 이나 개인정보 또는 암호가 담긴 중요한 파일들을 배제하는 것 권장 

.gitignore 에서 경로 지정 방법
/////.  # 이렇게 #를 사용해서 주석

# 모든 file.c
file.c

# 최상위 폴더의 file.c
/file.c

# 모든 .c 확장자 파일
*.c

# .c 확장자지만 무시하지 않을 파일
!not_ignore_this.c

# logs란 이름의 파일 또는 폴더와 그 내용들
logs

# logs란 이름의 폴더와 그 내용들
logs/

# logs 폴더 바로 안의 debug.log와 .c 파일들
logs/debug.log
logs/*.c

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Git 병합 2가지 방법


merge : 서브에서 진행된 커밋들이 존재한 상태로 병합
만약 서브에서 한 10개의 커밋들이 있고 최종 10번째 커밋만 메인에 합체 되고 나머지 9개의 내역들은 파생된 가지로 남아있음


Rebase : 서브에서 진행한 커밋들이 메인 브랜치에서 한것처럼 추가추가 되는 개념 (서브 커밋들이 사라짐)
총 10개의 커밋들이 있으면 얘네들은 메인 브랜치에 10개를 직접 커밋한거처럼 그냥 10개가 추가 되는 느낌 파생된 가지는 없는 것 처럼 보이고 메인 브랜치가 한줄로 보임


총 평가 : 진행하는 프로젝트 성격이 과거 내역들이 좀 필요한 프로젝트면 merge 그게 아니라 내역들을 깔끔하게 정리해도 된다 싶으면 rebase

Merge 방법 = git merge 병합할 브랜치명 // 메인 브랜치에 김경환 서브 브랜치 작업물을 병합할거면 브랜치는 먼저 메인으로 옮기고 git merge 김경환


Rebase 방법 = git rebase main // 얘는 멀지 방법이랑 반대로 실행됨 메인브랜치에 김경환 브랜치를 병합할 경우 먼저 김경환 브랜치로 이동 후 git rebase main 타이핑 한 다음 git switch main 으로 다시 메인 브랜치로 와서 git branch -d 김경환 이런식으로 리베이스 방식으로 병합한 브랜치를 삭제하는 방법

위 방법처럼 하면 소스트리에서 확인할 시 브랜치는 메인 하나만 남아있지만 히스토리(나뭇가지)에서 보면 브랜치이름은 없지만 merge 방식으로 병합한 히스토리 내역들은 남아있다. Rebase 는 내역이 안보임

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


Git 병합 도중 충돌이 일어날 시

메인이랑 서브 브랜치를 merge 사용 하여 병합 할 때 중복되는 내용이 있어 충돌이 일어날 경우

화면에 표시가 되는데 거기서 메인 브랜치 내용을 따라갈지 서브 브랜치 내용으로 적용할 지 선택해 주거나 충돌난 부분이 너무 많은 경우 git merge --abort 를 사용하여 메인으로 이동 함

수정을 완료했다면 git add . 애드하고
Git commit 으로엔터하면 자동으로 커밋 문구가 나오고 :wq 를 입력하여 커밋


Rebase 에서 충돌 수정은
먼저 서브 브랜치로 이동 후 git rebase main을 한다 그다음 충돌나는 구간에서 뭘 사용할지 선택 혹은 수정 후 git add . git rebase —continue 를 하여 커밋 메시지 등록 후 추가 충돌 여부 확인 추가 충돌이 있으면 똑같이 수정하고 git rebase —continue 충돌이 더이상 없으면 성공하였다는 메시지가 나옴

성공했으면 메인 브랜치로 이동 후 멀지 병합 후 딜리트 서브 브랜치
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


git remote add origin https://github.com/onedayonecommit/git-prac.git
			  저장소 이름
기본 원격 저장소 이름 = origin 보통 디폴트값


git branch -M main
메인 브런치 이름을 main으로 변경해주겠다 의미
원래라면 master 하지만 난 config로 미리 main 변경함

git push -u origin main
커밋된 걸 푸쉬 하겠다는 거고 어느 원격저장소에 어떤 브랜치에 집어넣을 지 적는 거

git remote remove (origin 등 원격 이름) 연결을 끊어주겠다는 문구 깃헙 레퍼지토리는 그대로 남아있음

Git clone (깃 주소) 입력 시 .git 폴더 포함 다운로드 됌 이전 관리 내역 전부 확인 가능

Push 할 것이 있는데 pull 도 해야되면 
Git pull —no-rebase : merge 방식이며 커밋메시지도 같이 등록 해야됌

그럼 갈라지는게 위에서 병합되는 형식

Git pull —rebase = 리베이스 방식임